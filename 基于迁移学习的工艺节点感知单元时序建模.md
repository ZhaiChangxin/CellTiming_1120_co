# 基于迁移学习的工艺节点感知单元时序建模

## 总体技术路线（单元级、跨工艺、可落地）

1. **问题定义（Cell-level delay model）**
    给定标准单元 `cell`、弧 `(pin_in→pin_out)`、输入 `slew_in`、输出 `cap_out`、PVT 以及**最小上下文**（如驱动/负载门型、Fanout），学习函数

d^=fθ(cell_id,arc,slew_in,cap_out,PVT,context)\hat{d}=f_\theta(\text{cell\_id}, \text{arc}, \text{slew\_in}, \text{cap\_out}, \text{PVT}, \text{context})d^=fθ(cell_id,arc,slew_in,cap_out,PVT,context)

目标是在**目标工艺节点**（如 ASAP7）上用极少标注数据取得高精度，同时可从**先行工艺节点**（如 Nangate45 / Sky130）迁移来提升泛化。

1. **数据与标签（不做老化）**

- **标签**：优先用 `.lib` 的 NLDM/CCS 表格做 GT（插值后平滑），必要时抽样点用 SPICE 校正（低成本对齐）。
- **样本构造**：对每条弧，网格化采样 `(slew_in, cap_out)`；覆盖不同驱动强度、VT、门型变体。
- **跨节点对齐**：建立**门功能族映射**（INV/NAND/NOR/XOR/MUX 等）与**驱动强度归一**（例如按 `(W/L)` 或以 `.lib` 中 `cell_rise/fall` 的典型点表征强弱等级），确保节点间“同一语义”可对应。

1. **特征设计（单元级而非路径级）**

- **原子特征**：one-hot/embedding 的 `gate_func`、`drive_strength`、`VT`、`pin role`；数值特征的 `slew_in`、`cap_out`、`V/T`、`VDD`、`temp`、`rise/fall` 标志。
- **轻量上下文**（可逐步添加）：前一级驱动门型/强度、后级负载门型/强度、fanout、邻近拓扑深度=1 的度量（避免走向路径级）。
- **图表示（可选增强）**：把“目标单元+一跳邻域”建成**小型异构图**（pin/cell 两类点，cell-edge / net-edge 两类边），用 HGAT/HetGNN 聚合后得到**cell-in-context** embedding，再与 `slew/cap/PVT` 数值特征拼接进入读出层。这样保留“单元级”范式，同时获得有限上下文感知。

1. **迁移学习策略（借鉴 AdaTimer，但重构为单元级）**

- **特征解耦（Disentangle）**
  - **节点相关（node-dependent）**：与工艺、电气参数强相关的部分（如库电气规模、驱动强度、VT、PVT）。
  - **设计相关（design-dependent）**：与逻辑功能族、弧位/拓扑上下文相关，但相对**与节点无关**。
     具体做法：共享主干编码器后，用两支 MLP 分头投影成 `u_node` 与 `u_design`，分别用于对齐与正则。
- **对齐（Align）**
  - **节点对比损失**：同一工艺节点的 `u_node` 拉近、不同节点拉远；促使“节点指纹”在同域内一致、跨域可分。
  - **设计分布对齐损失**：对 `u_design` 做分布统计对齐（如 CMD/MMD），使同一功能/上下文在跨节点分布接近。
- **可迁移性重加权（Reweight）**
  - 用**门功能族+驱动等级直方图**构成“单元样本的类型分布”，跨节点按**OT/Sinkhorn**距离评估与目标域相似度；对**源域样本**赋权，抑制负迁移（老门型/罕见组合的错配）。
- **贝叶斯读出（Bayesian head）**
  - 将**最后线性读出层权重**设为分布（变分参数化），在**小样本目标域**下获得更稳健的**不确定性建模与防过拟合**（也可用 MC Dropout 作轻量替代基线）。

1. **模型谱系（建议实验阶梯）**

- **Baseline-0（Lib-MLP）**：纯数值特征 + 2~3 层 MLP（带输入标准化与`log1p/Box-Cox`目标变换）。
- **Baseline-1（Lib-MLP + Pretrain-FT）**：在源节点预训练，再在目标节点少量数据上微调。
- **Model-A（Disentangle+Align）**：加入 `u_node/u_design` 分头对齐损失。
- **Model-B（A+Bayesian head）**：换成变分读出层。
- **Model-C（B+Reweight）**：引入 OT 重加权。
- **Model-D（C+HGAT 小图）**：加入一跳上下文图编码，验证“cell-in-context”收益与代价。

1. **评测协议与指标**

- **拆分**：按**cell 类型**与**上下文组合**分层抽样；保证一部分门型/驱动等级在目标域**低覆盖**以检验迁移效果。
- **指标**：MAE / RMSE / NRMSE（相对 `.lib` 标称）、P95 误差、上/下延的独立指标；画 `(slew, cap)` 网格热力误差图。
- **消融**：去掉对比/对齐/重加权/贝叶斯逐一对比分量贡献；不同源域规模（1/2/4 个节点或多设计）曲线。

1. **工程落地**

- **训练数据管线**：`lib_parser -> arc_list -> (slew,cap) 网格 -> lib插值得GT -> (可选) SPICE抽查校正 -> TFRecord/CSV`。
- **推理接口**：导出为 `f(cell, arc, slew, cap, PVT, context) -> delay` 的 Python/C++ API；
  - **对接 OpenTimer/STA** 两种方式：
    1. **离线生成伪 `.lib`**（把模型推断的网格表写回 NLDM/CCS 表格）；
    2. **在线查询**（Hook 延迟查询回调，遇到未覆盖网格做模型推断与双线性插值）。
- **一致性保障**：上/下延对称性、单调性（对 `slew/cap` 的单调约束可通过**软约束正则**或**输入排序+积分网络**实现）。

# 最小可行实验（两周内能出曲线）

- **数据**：选 2 个节点（Nangate45→ASAP7），5 个门型（INV/NAND2/NOR2/XOR2/MUX2），每型 3 个驱动等级，100×100 的 `(slew,cap)` 网格。
- **模型**：Baseline-0 与 Model-B（含变分读出）；不做图上下文。
- **迁移**：源域全量预训练；目标域每门型取 5% 网格点微调；对比**仅目标域训练** vs **迁移**。
- **结果**：出 3 张图——整体 MAE、每门型 MAE、网格误差热力图（可见迁移改善的区域）。

# 与两篇论文的“取其精华”

- **承接 AdaTimer**：用“**特征解耦 + 分布对齐 +（可选）可迁移性重加权 + 贝叶斯读出**”的思想，但把**路径级**的多模态与大图传播，简化为**单元级**的数值/轻上下文表示；把“设计相关 vs 节点相关”的边界，重定义到**门功能与弧位**（设计侧） vs **库电气/工艺/PVT**（节点侧）。
- **承接 CellTiming（去老化）**：沿用其**单元弧建模范式**与 `(slew,cap)` 网格训练/评测思路，但移除老化相关输入与损失项。

# 里程碑（示意 12~16 周）

1. W1–W2：数据与评测基线打通（N45→A7，5 门型）。
2. W3–W4：特征解耦 + 对齐损失（CMD/MMD）验证。
3. W5–W6：贝叶斯读出/MC Dropout 对比，小样本鲁棒性实验。
4. W7–W8：OT 重加权与负迁移分析。
5. W9–W10：HGAT 一跳上下文增强（可选）。
6. W11–W12：OpenTimer 对接（离线 `.lib` 生成与在线查询二选一）。
7. W13+：大规模扩展（更多门型/节点）、论文图表与消融收敛。



# 一页摘要（给导师和评审先读）

- **课题定位**：在单元级（cell-level）完成不同工艺节点间的**时序迁移学习**，以INVX1为MVP验证；采用**异构图注意力网络（HGAT）**做单元级结构嵌入，不考虑老化效应与路径级注意力。
- **对比参照**：
  - *CellTiming*：采用H-GAT表征单元内部多类型器件与弧（timing arc），面向老化感知；本课题**只借鉴其单元建模与异构图思想**。
  - *AdaTimer*：提出跨工艺节点的**特征解耦+对齐**与**Bayesian回归**，面向路径级预测；本课题**将迁移学习思想下放到单元级**。
- **MVP范围**：ASAP7与Nangate45的INVX1，输入**.sp**网表（不依赖老化模型），基础PVT/加载/输入slew特征；输出rise/fall延迟；**先不做路径注意力与多单元泛化**。
- **主要贡献（MVP）**：
  1. 单元内部异构图构建（Tr/C/R节点与连接）；2) HGAT编码器 + MLP回归；3) 简化的跨节点迁移（设计相关/工艺相关潜表征拆分 + 轻量对齐损失）；4) 可复现实验脚本与日志。

------

# 1. 研究背景与问题定义

- **痛点**：跨节点重建单元库时序开销大；传统LUT或ML特征难以刻画单元内部的**器件/弧拓扑**；需要**小样本跨节点迁移**。
- **本课题目标**：给定不同工艺节点的**单元SPICE网表（.sp/.spi）\**与操作条件（PVT、input slew、output cap），学习\**单元级延迟模型**，并可**从源节点迁移到目标节点**。

------

# 2. 相关工作与本课题定位

- **CellTiming（TCAS-II 2024）**：提出H-GAT聚合单元内**多类型器件（Tr/C/R）与路径（cell paths）\**的信息，用池化得到\**cell embedding**，再回归老化感知延迟。本课题**延用其单元图建模范式**，但**不引入老化**、**不做路径级注意力**（MVP阶段）。
- **AdaTimer（TCAD 2025）**：针对**跨工艺节点**的路径级预测，提出**节点相关 vs 设计相关**特征**解耦**，用**对比学习/分布差异（CMD）\**进行\**双通道对齐**，并用**Bayesian回归**提高**高方差延迟**的泛化。本课题**借鉴其迁移学习机制**，但**在单元级实现**。
- **差异小结**：
  - 预测粒度：路径级（AdaTimer）→ **单元级（本课题）**；
  - 物理建模：老化感知（CellTiming）→ **普通时序（本课题）**；
  - 图结构：保留CellTiming的**异构图**思想；
  - 迁移框架：借鉴AdaTimer的**解耦+对齐+Bayes**，做**轻量化单元版**。

------

# 3. 数据与预处理（严格按当前代码）

- **数据构建脚本**：`build_dataset.py`（已在仓库）。功能：
  - 从 `--src_lib`、`--tgt_lib` 解析 INVX1 的 `cell_rise/cell_fall/rise_transition/fall_transition` 四张表，并从 `.lib` 头部读出 `nom_voltage/nom_temperature`；统一单位到 **ps**（时间）、**pF**（电容）。
  - 自动求交集：对源/目标两库的 `slew, cap` 取**交集范围**并在此区间做**双线性插值**到规则网格（默认 `--grid_slew=12, --grid_cap=12`）。
  - 可选解析 `.sp/.spi` 以提取器件级统计特征：`wp_sum, wn_sum, wp_over_wn`（按 W 聚合，也就是 PMOS、NMOS 总宽与比值）。
  - 生成三份 CSV：`src_delay.csv`、`tgt_delay_labeled.csv`（按 `--target_label_ratio` 采样，默认 10%）与 `tgt_delay_unlabeled.csv`；并输出 `meta.json`（记录网格与样本规模）。
- **CSV 列（最小可用集）**：`[tech, pol, slew, cap, voltage, temp, delay, wp_over_wn, wp_sum, wn_sum, is_inv, stack_pu, stack_pd]`
  - 训练/评测真正使用的**数值特征列**为：`slew, cap, voltage, temp, wp_over_wn, wp_sum, wn_sum, is_inv, stack_pu, stack_pd, pol_bit`（`pol_bit` 由 `pol` 生成：rise→1，else→0）。
- **标准化**：训练阶段把 `src + tgt_labeled` 拼起来按列估计 `x_mean/x_std` 与 `y_mean/y_std`，分别保存到 `scaler.json / scaler_stats.json / y_scaler.json`；评测阶段加载并对输入/输出做反向还原。

------

# 4. 模型设计（严格按当前代码）

## 4.1 主体回归器 `DisentangledRegressor`

- **输入**：`x∈R^{11}`（见上面的数值列），可选**外部设计向量**`z_design`（来自 HGAT）。
- **结构**：
  - `enc`: `Linear(in,hid) → ReLU → Linear(hid,hid) → ReLU`（默认 `hid=128`）。
  - **解耦**：
    - `z_node = split_node(h)`，维度 `z_dim=64`（默认）；
    - `z_design`：两种工作模式
      1. **非 HGAT**：`split_design(h)` 产生内部设计子空间（维度同 `z_dim`）。
      2. **HGAT 开启**：关闭内部 `split_design`，改为 **外部注入** `z_design_external`，并把 `design_dim_override=64` 写入 ckpt。
  - `head`: `Linear(z_node ⊕ z_design, hid) → ReLU → Linear(hid,hid/2) → ReLU`；
  - 输出：`mu, log_var`（标量），采用高斯负对数似然监督；同时返回 `z_node, z_design` 供损失计算。

## 4.2 HGAT 设计编码器 `HGATDesignEncoder`

- **图构建（异构图）**：
  - **节点类型**：`NET, PMOS, NMOS`；
  - **边类型**：`NET→PMOS (gate_of)`, `PMOS→NET (sd_to)`, `NET→PMOS (back_sd)`；NMOS 对称；
  - **节点特征**：
    - `NET`: `[is_vdd, is_vss, is_a, is_y/ZN]`（one-hot 风格）；
    - `PMOS/NMOS`: `[W, L]`（缺失补 0）。
- **编码**：每类节点线性投影到 `hid`，两层 `HeteroGraphConv{GATConv}`，每层对多头取均值，再对 PMOS/NMOS 做 mean-pooling，最后 `MLP(readout)` 得到 `z_design∈R^{64}`。
- **训练/评测接口**：
  - **训练时**（当前代码）：`enc` 被实例化，`z_src, z_tgt` 由当前 `.sp/.spi` 图各算一次并喂入主模型；
  - **评测时**：从 ckpt 读出 `enc` 的权重（若有），对 `--tgt_spice` 再算一次 `z_tgt`，整批样本复用同一 `z_tgt`。

------

# 5. 迁移学习/损失设计（严格按当前代码）

- **监督项（NLL）**：源域与目标域标注部分各自的 `GaussianNLL(mu, log_var, y)` 求和。
- **分布对齐（CMD）**：对**设计子空间**在**源标注 vs 目标未标注**之间做 `CMD(K=5, λ_cmd=0.1)`；实现上对每维做标准化后对齐 1..K 阶中心矩并对特征维度做均值；
- **监督对比（SupCon）**：在**节点子空间**上做有监督对比学习，`label=域标签 (src=0,tgt=1)`，温度 `τ=0.1`，鼓励同域样本靠近、跨域分离；
- **总损失**：`Loss = NLL + λ_cmd·CMD + λ_supcon·SupCon`，默认 `λ_supcon=0.05`。

> 说明：当前实现采用**外部设计向量**（HGAT 输出）替代内部 `split_design`，因此 CMD 是在**外部 z_src vs z_tgt** 上对齐；评测阶段整批样本共享同一个 `z_tgt`。

------

# 6. 训练/评测流程与脚本接口（严格按当前代码）

## 6.1 训练 `train.py`

- **输入**：`outputs/src_delay.csv`, `outputs/tgt_delay_labeled.csv`, `outputs/tgt_delay_unlabeled.csv`；可选 `--use_hgat --src_spice --tgt_spice`。
- **标准化**：基于 `src + tgt_labeled` 估计 scaler 并保存到 `scaler.json / scaler_stats.json / y_scaler.json`。
- **模型**：`DisentangledRegressor(in_dim=11,hid=128,design_dim_override=64 if use_hgat else None)`。
- **HGAT**：若 `--use_hgat`，构建源/目标各一张异构图，计算 `z_src/z_tgt`（默认 64 维）。
- **优化**：Adam(lr=2e-3)，`epochs=120, batch=256`；保存 **最小 NLL** 对应的 ckpt，包含 `model/enc/hgat_in_dim_map/design_dim/numeric_cols`。
- **损失**：如第 5 节。

## 6.2 评测 `eval.py`

- **CSV 选择顺序**：优先 `tgt_delay_labeled.csv`，否则尝试 `target_test.csv` 或 `tgt.csv`；
- **scaler 加载**：优先新格式 `scaler_stats.json + y_scaler.json`，回退到 `scaler.json`；
- **HGAT**：若 `--use_hgat`，重建 `HGATDesignEncoder` 并**加载 ckpt 的 enc 权重**（若存在），对 `--tgt_spice` 计算一次 `z_tgt` 并复用；
- **反标定**：`mu·y_std + y_mean` 还原到 ps；
- **指标**：MAE、R²；在控制台输出。

------

# 7. 实验设计（MVP两周即可复现）

- **数据划分**：源节点（Nangate45）充足采样，目标节点（ASAP7）小样本（如10~20%）；弧别评测（rise/fall）。
- **对比组**：
  1. 仅目标节点小样本；2) 源+目标简单合并；3) 参数共享（同编码器、节点专属头）；4) 预训练→微调；5) **本方法-解耦+对齐**；6) **本方法+Bayesian**（可选）。
- **指标**：MAE(ps)、R²、推理时延（ms/样本）、模型大小（MB）。
- **消融**：
  - 去掉C/R节点；
  - 去掉解耦/对齐任一模块；
  - 去掉Bayesian；
  - 仅Tr-only vs Tr+C/R。

------

# 8. 当前实验结果（基于你提供的日志）

- **不使用 HGAT（非外部设计向量）**：MAE = **48.36337 ps**，R² = **0.5677**。
- **使用 HGAT（外部设计向量）**：MAE = **88.24231 ps**，R² = **-0.5343**。

> 初步结论：当前 HGAT 管线在 MVP 设置下**未带来收益，且显著退化**。详见下一节“问题定位与修复计划”。

------

# 9. 路线图

- **Week 1**：完成Tr-only图与HGAT最小版；跑通源→目标微调与解耦+对齐；
- **Week 2**：加入C/R节点（如数据可得）、尝试Bayesian读出层；完成全部对比与消融；撰写小结报告。

------

# 9. 代码一致性 — 问题定位与修复计划

1. **HGAT 编码器未参与训练**：
   - 目前 `opt = Adam(model.parameters())` 仅优化主回归器；`enc` 未加到优化器里，且 `compute_z()` 内部 **`no_grad + detach()`**，导致 `z_src/z_tgt` 为**常量且不受损失驱动**。这会直接解释“使用 HGAT 反而变差”。
   - **修复**：
     - 把 `enc.parameters()` 加入优化器；去掉 `with torch.no_grad()` 与 `detach()`；
     - 让 `NLL/CMD` 的梯度能回传到 `enc`，实现**端到端**学习 `z_design`。
2. **CMD 对齐对象为两个常量向量**：
   - 由于上面原因，`z_src/z_tgt` 在一个 epoch 内几乎不变，`CMD` 退化为**常数之间的差**，几乎不起正则作用。
   - **修复**：同上端到端；或把 `z_design` 改为**随 batch 构图的子图表示**（如针对 rise/fall 或不同驱动/负载条件构建轻微扰动的 z）。
3. **设计向量过于贫乏**：
   - 图特征仅 `[W,L]` 与少量 NET one-hot，信息量有限；
   - **增强**：增加（可从 .sp 中解析的）指数量 `nf`、并/串拓扑统计、到输出引脚的拓扑距离、驱动扇出估计、体极连接模式等。
4. **评测复用单一 `z_tgt`**：
   - 评测阶段整批共享同一 `z_tgt`，无法反映不同负载/极性的细微差异；
   - **增强**：至少按 `pol_bit`（rise/fall）分别计算或拼接两个 `z_tgt`；进一步可按弧/负载簇采样多个 `z_tgt` 并在模型中做门控或注意力融合。

# 10. 风险与对策（更新）

- **HGAT 不收敛/无收益** → 启用端到端训练 + 丰富图特征 + 分批 z 生成；若短期仍不稳，提供**非 HGAT**版本作为基线（当前已优于 HGAT）。
- **目标域样本更少** → 提高 `λ_cmd`、降低 `τ`；或先做**预训练→微调**备选实验链路。
- **工程保障** → 在 ckpt 中固定记录 `design_dim` 与 `numeric_cols`（已实现），评测重建时严格对齐（已实现）。





## MVP（最小可行）对比 目标最终版本

| 方面             | **当前 MVP（代码现状）**                                     | **目标最终版本（建议、且与论文思想一致）**                   |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 设计向量（HGAT） | 每域仅 1 个 `z_src/z_tgt`，**常量**、**不参与训练**（`no_grad+detach`；优化器未包含 `enc`） | **端到端训练**：将 `enc.parameters()` 加入优化器，去掉 `no_grad()/detach()`；让 **NLL/CMD** 的梯度回传到 `HGAT` |
| CMD 对齐         | 对齐两个“常量向量”（弱）                                     | 对齐**可学习的** `z_src` vs `z_tgt`；可把 `z_design` **细化到子条件**（例如按 `pol_bit` 分两份 `z_tgt_rise/fall`，或按负载簇抽多份 `z_tgt` 并做门控/注意力融合） |
| 图特征           | `NET` 仅 4 个 flag；MOS 仅 `[W,L]`                           | 丰富**可从 .sp 稳定抽取**的特征：`nf`、并/串深度、到输出 pin 的拓扑距离、体极连接模式、扇出估计、关键通路近邻统计等 |
| 监督/对比        | SupCon 用**域标签**区分（src/tgt），合理                     | 可再加入**类标签/弧标签**（rise/fall）作为二级监督（若你扩展到多单元/多弧场景） |
| 目标头           | 高斯 `mu/log_var`，已实现                                    | 可加**Bayesian读出**（权重概率化 + KL 正则）提升小样本/高方差稳健性（AdaTimer 思想，下放到单元级） |
| 数据构成         | 单一单元 INVX1；目标域 10% 标注                              | 扩到多单元（INVX2/3/NAND/NOR…）、多弧；目标域标注比例多档（1%、5%、10%…）做迁移曲线 |
| 评测 z 复用      | 整批共享 1 个 `z_tgt`                                        | 至少按 `pol_bit` 区分；可按负载簇或图扰动生成**多 `z`**，在模型端融合 |
| 可复现实验       | 已可跑通（两周范围）                                         | 完整对比/消融（无 HGAT / 端到端 HGAT / +CMD / +SupCon / +Bayesian / +特征增强），并报告稳定性（方差/收敛曲线） |